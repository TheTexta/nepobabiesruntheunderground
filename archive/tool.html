<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tool</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #111;
    }
    canvas { width: 100%; height: 100%; display: block; }
    #menu-button {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 32px;
      height: 32px;
      background: url('assets/images/favicons/favicon.png') no-repeat center/contain;
      cursor: pointer;
      z-index: 10;
    }
    #menu {
      position: fixed;
      top: 50px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      padding: 8px;
      border-radius: 4px;
      display: none;
      z-index: 10;
    }
    #menu.show { display: block; }
    #file-list {
      margin: 10px 0;
      max-height: 300px;
      overflow-y: auto;
    }
    .file-item {
      background: rgba(0,0,0,0.1);
      padding: 8px;
      margin: 5px 0;
      border-radius: 4px;
      border-left: 3px solid #007acc;
    }
    .file-item.created {
      border-left-color: #28a745;
    }
    .file-name {
      font-weight: bold;
      margin-bottom: 5px;
      font-size: 12px;
    }
    .file-controls {
      display: flex;
      gap: 5px;
      align-items: center;
      flex-wrap: wrap;
    }
    .file-controls label {
      font-size: 11px;
    }
    .file-controls select {
      font-size: 11px;
      padding: 2px;
    }
    .file-controls button {
      font-size: 11px;
      padding: 2px 6px;
    }
    #mouse-pos {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      z-index: 10;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="menu-button" title="Menu"></div>
  <div id="menu">
    <label>
      Upload Images
      <input type="file" id="file-input" multiple accept="image/*">
    </label>
    <div id="file-list"></div>
    <br>
    <label>
      Exposure (Global)
      <input type="range" id="exposure" min="-1" max="1" step="0.05" value="0">
    </label>
    <br>
    <button id="randomize">Randomize</button>
    <br><br>
    <button id="reset-view">Reset View</button>
    <button id="clear-all">Clear All</button>
  </div>
  <div id="mouse-pos">Mouse: (0, 0)</div>
  
  <!-- Load PixiJS as UMD -->
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.11.0/dist/pixi.min.js"></script>
  
  <script>
    // PixiJS is now available globally, destructure what we need
    const { Application, Container, Sprite, Graphics, Texture, ColorMatrixFilter } = PIXI;

    // === PIXI Setup ===
    async function initPixi() {
      const app = new Application();
      await app.init({ resizeTo: window, background: '#222' });
      document.body.appendChild(app.canvas);

      const world = new Container();
      app.stage.addChild(world);

      // Center the world on page load
      world.x = app.screen.width / 2;
      world.y = app.screen.height / 2;

      // === Visual Guides ===
      function createVisualGuides() {
        const spawnArea = new Graphics();
        spawnArea.rect(-400, -300, 800, 600);
        spawnArea.stroke({ color: 0x00ff00, width: 2 });
        spawnArea.fill({ color: 0x000000, alpha: 0.1 });
        world.addChild(spawnArea);

        // Create mask for the world to hide sprites outside the spawn area
        const mask = new Graphics();
        mask.rect(-400, -300, 800, 600);
        mask.fill({ color: 0xffffff });
        world.addChild(mask);
        world.mask = mask;

        const axisLines = new Graphics();
        axisLines.moveTo(-400, 0).lineTo(400, 0);
        axisLines.moveTo(0, -300).lineTo(0, 300);
        axisLines.stroke({ color: 0x666666, width: 1 });
        world.addChild(axisLines);

        const centerMarker = new Graphics();
        centerMarker.circle(0, 0, 5);
        centerMarker.fill({ color: 0xff0000 });
        world.addChild(centerMarker);
      }
      createVisualGuides();

      // === Image Manager Class ===
      class ImageManager {
        constructor() {
          this.images = new Map(); // id -> ImageData
          this.nextId = 1;
          this.exposureFilter = new ColorMatrixFilter();
        }

        addFile(file) {
          const id = this.nextId++;
          const imageData = {
            id,
            file,
            name: file.name,
            sprite: null,
            blendMode: 'normal',
            created: false
          };
          this.images.set(id, imageData);
          return imageData;
        }

        removeImage(id) {
          const imageData = this.images.get(id);
          if (!imageData) return;
          
          if (imageData.sprite) {
            world.removeChild(imageData.sprite);
            imageData.sprite = null;
          }
          this.images.delete(id);
        }

        createSprite(id) {
          const imageData = this.images.get(id);
          if (!imageData) return;

          // Remove existing sprite if any
          if (imageData.sprite) {
            world.removeChild(imageData.sprite);
          }

          const img = new Image();
          img.onload = () => {
            const texture = Texture.from(img);
            // Set nearest neighbor scaling for pixelated appearance
            texture.source.scaleMode = 'nearest';
            const sprite = new Sprite(texture);
            
            sprite.anchor.set(0.5);
            // Position sprites closer together so they overlap for blending
            sprite.x = (Math.random() - 0.5) * 400; // Smaller spread
            sprite.y = (Math.random() - 0.5) * 300;
            sprite.scale.set(0.5 + Math.random() * 0.5); // Larger sprites
            sprite.blendMode = imageData.blendMode;
            
            imageData.sprite = sprite;
            imageData.created = true;
            world.addChild(sprite);
            
            UI.updateImageItem(imageData);
            console.log(`Created sprite with blend mode: ${imageData.blendMode}`);
          };
          img.src = URL.createObjectURL(imageData.file);
        }

        updateBlendMode(id, blendMode) {
          const imageData = this.images.get(id);
          if (!imageData) return;
          
          console.log(`Updating blend mode for ${imageData.name}: ${blendMode}`);
          imageData.blendMode = blendMode;
          
          if (imageData.sprite) {
            imageData.sprite.blendMode = blendMode;
            console.log(`Applied blend mode to sprite: ${imageData.sprite.blendMode}`);
          }
        }

        updateExposure(value) {
          this.exposureFilter.reset();
          this.exposureFilter.brightness(value + 1, false);
          this.images.forEach(imageData => {
            if (imageData.sprite) {
              // Only apply exposure filter if exposure is not at default (0)
              if (value !== 0) {
                imageData.sprite.filters = [this.exposureFilter];
              } else {
                imageData.sprite.filters = []; // Remove filters to avoid blend mode interference
              }
            }
          });
        }

        randomizeSprites() {
          const modes = ['normal', 'add', 'multiply', 'screen'];
          this.images.forEach(imageData => {
            if (imageData.sprite) {
              // Keep sprites closer together for better blending visibility
              imageData.sprite.x = (Math.random() - 0.5) * 400;
              imageData.sprite.y = (Math.random() - 0.5) * 300;
              imageData.sprite.scale.set(0.5 + Math.random() * 0.5);
              const randMode = modes[Math.floor(Math.random() * modes.length)];
              imageData.sprite.blendMode = randMode;
              imageData.blendMode = randMode;
            }
          });
          UI.refreshAll();
        }

        clearAll() {
          this.images.forEach(imageData => {
            if (imageData.sprite) {
              world.removeChild(imageData.sprite);
            }
          });
          this.images.clear();
          this.nextId = 1;
        }

        getAllImages() {
          return Array.from(this.images.values());
        }
      }

      // === UI Manager ===
      class UI {
        static init() {
          this.fileInput = document.getElementById('file-input');
          this.fileList = document.getElementById('file-list');
          this.exposureInput = document.getElementById('exposure');
          
          this.fileInput.addEventListener('change', this.handleFileSelect.bind(this));
          this.exposureInput.addEventListener('input', this.handleExposureChange.bind(this));
          
          document.getElementById('randomize').addEventListener('click', () => imageManager.randomizeSprites());
          document.getElementById('clear-all').addEventListener('click', this.handleClearAll.bind(this));
          document.getElementById('reset-view').addEventListener('click', this.handleResetView.bind(this));
          
          const menuButton = document.getElementById('menu-button');
          const menu = document.getElementById('menu');
          menuButton.addEventListener('click', () => menu.classList.toggle('show'));
        }

        static handleFileSelect(event) {
          Array.from(event.target.files).forEach(file => {
            const imageData = imageManager.addFile(file);
            this.addImageItem(imageData);
          });
        }

        static handleExposureChange(event) {
          imageManager.updateExposure(parseFloat(event.target.value));
        }

        static handleClearAll() {
          imageManager.clearAll();
          this.fileList.innerHTML = '';
          this.fileInput.value = '';
        }

        static handleResetView() {
          world.x = app.screen.width / 2;
          world.y = app.screen.height / 2;
          world.scale.set(1);
        }

        static addImageItem(imageData) {
          const item = document.createElement('div');
          item.className = 'file-item';
          item.dataset.id = imageData.id;
          
          item.innerHTML = `
            <div class="file-name">${imageData.name}</div>
            <div class="file-controls">
              <label>Blend:</label>
              <select data-action="blend">
                <option value="normal">Normal</option>
                <option value="add">Add</option>
                <option value="multiply">Multiply</option>
                <option value="screen">Screen</option>
              </select>
              <button data-action="create">Create</button>
              <button data-action="remove">Remove</button>
            </div>
          `;

          // Add event listeners
          item.addEventListener('click', (e) => this.handleItemClick(e, imageData.id));
          item.addEventListener('change', (e) => this.handleItemChange(e, imageData.id));
          
          this.fileList.appendChild(item);
        }

        static handleItemClick(event, imageId) {
          const action = event.target.dataset.action;
          
          switch (action) {
            case 'create':
              imageManager.createSprite(imageId);
              break;
            case 'remove':
              imageManager.removeImage(imageId);
              event.target.closest('.file-item').remove();
              break;
          }
        }

        static handleItemChange(event, imageId) {
          const action = event.target.dataset.action;
          
          if (action === 'blend') {
            imageManager.updateBlendMode(imageId, event.target.value);
          }
        }

        static updateImageItem(imageData) {
          const item = document.querySelector(`[data-id="${imageData.id}"]`);
          if (!item) return;
          
          if (imageData.created) {
            item.classList.add('created');
            const createBtn = item.querySelector('[data-action="create"]');
            createBtn.textContent = 'Recreate';
          }
          
          const blendSelect = item.querySelector('[data-action="blend"]');
          blendSelect.value = imageData.blendMode;
        }

        static refreshAll() {
          imageManager.getAllImages().forEach(imageData => this.updateImageItem(imageData));
        }
      }

      // === Mouse Tracking ===
      function setupMouseTracking() {
        const mousePosDisplay = document.getElementById('mouse-pos');
        
        window.addEventListener('pointermove', (e) => {
          const rect = app.canvas.getBoundingClientRect();
          const canvasX = e.clientX - rect.left;
          const canvasY = e.clientY - rect.top;
          const worldX = (canvasX - world.x) / world.scale.x;
          const worldY = (canvasY - world.y) / world.scale.y;

          mousePosDisplay.textContent =
            `Mouse: Screen(${e.clientX}, ${e.clientY}) ` +
            `Canvas(${Math.round(canvasX)}, ${Math.round(canvasY)}) ` +
            `World(${Math.round(worldX)}, ${Math.round(worldY)})`;
        });
      }

      // === Camera Controls ===
      function setupCameraControls() {
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        app.canvas.addEventListener('pointerdown', (e) => {
          isDragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
          app.canvas.style.cursor = 'grabbing';
        });

        window.addEventListener('pointerup', () => {
          isDragging = false;
          app.canvas.style.cursor = 'default';
        });

        window.addEventListener('pointermove', (e) => {
          if (!isDragging) return;
          world.x += e.clientX - lastX;
          world.y += e.clientY - lastY;
          lastX = e.clientX;
          lastY = e.clientY;
        });

        app.canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const scaleFactor = e.deltaY < 0 ? 1.05 : 0.95; // Half the zoom speed (was 1.1/0.9)
          const rect = app.canvas.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;
          
          // Define center deadzone (50px radius from center)
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          const distanceFromCenter = Math.sqrt((mx - centerX) ** 2 + (my - centerY) ** 2);
          const deadzoneRadius = 20;
          
          let zoomX, zoomY;
          if (distanceFromCenter < deadzoneRadius) {
            // Zoom from center of screen
            zoomX = centerX;
            zoomY = centerY;
          } else {
            // Zoom from mouse position
            zoomX = mx;
            zoomY = my;
          }
          
          const worldX = (zoomX - world.x) / world.scale.x;
          const worldY = (zoomY - world.y) / world.scale.y;
          const newScale = world.scale.x * scaleFactor;
          world.scale.set(newScale);
          world.x = zoomX - worldX * newScale;
          world.y = zoomY - worldY * newScale;
        });
      }

      // === Initialize ===
      const imageManager = new ImageManager();
      UI.init();
      setupMouseTracking();
      setupCameraControls();
      imageManager.updateExposure(0); // Initialize exposure filter
      
      // Expose world object for testing
      window.world = world;
      window.app = app;
      window.imageManager = imageManager;
    }

    // Initialize the application
    initPixi().catch(console.error);
  </script>
</body>
</html>
