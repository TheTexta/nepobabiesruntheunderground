<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

  <!-- Favicons -->
  <link rel="icon" type="image/png" href="/assets/images/favicons/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/assets/images/favicons/favicon.svg" />
  <link rel="shortcut icon" href="/assets/images/favicons/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicons/apple-touch-icon.png" />
  <meta name="apple-mobile-web-app-title" content="MyWebSite" />
  <link rel="manifest" href="/assets/images/favicons/site.webmanifest" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>images</title>

  <style>
    html {
      -webkit-text-size-adjust: 100%;
    }

    input {
      user-select: none;
      height: 3px;
      margin: 10px;
    }


    div {
      position: absolute;
      top: min(1vw, 1vh);
      left: min(1vw, 1vh);
      background-color: rgba(255, 255, 255, 0.274);
      text-align: center;
    }

    p {
      margin: 0;
      padding: 0px;
      font-size: 0.8rem;
    }

    button {
      position: absolute;
      padding-left: 0.3rem;
      padding-right: 0.3rem;
      font-size: 1rem;
      text-align: center;
      background-color: rgba(255, 255, 255, 0.274);
      border: none;
      cursor: pointer;
      top: 2%;
    }

    body::-webkit-scrollbar {
      display: none;
    }

    body {
      scrollbar-width: none;
      overflow: hidden;
    }
  </style>

</head>

<body style="margin:0px">
  <button onclick="location.href='index.html'" style="pointer-events:all; right:min(1vw, 1vh); top:min(1vw, 1vh); ">==></button>
  <main>
    <button id="menuOpen" style="pointer-events:all; display: none; left:min(1vw, 1vh); top:min(1vw, 1vh);">â˜°</button>

    <div id="menu">
      <button id="menuClose" style="right: 2%;">X</button>

      <p>Simulation Alpha: </p>
      <p id="alphaDisplay">1.000</p>
      <p>Hide Connections <input type="checkbox" id="hideConnections" style="height:10px;margin:0px"></p>
      <input type="range" min="0" max="5" value="1" id="charge" step="any">
      <p id="chargeDisplay">1.0</p>
      <input type="range" min="0" max="500" value="10" id="distMin" step="any">
      <p id="distMinDisplay">Distance Min Mult:</p>
      <input type="range" min="0" max="50" value="10" id="distMax" step="any">
      <p id="distMaxDisplay">Distance Max Mult:</p>
    </div>


    <canvas id="photoCanvas" style="height:100%;width:100%; margin:0px; image-rendering: -webkit-optimize-contrast;image-rendering: -moz-crisp-edges; image-rendering: pixelated;"></canvas>

  </main>

  <script type="module">

    document.getElementById("menuOpen").onclick = function () {
      document.getElementById("menu").style.display = "block";
      this.style.display = "none";
      document.getElementById("menuClose").style.display = "block";
    };
    document.getElementById("menuClose").onclick = function () {
      document.getElementById("menu").style.display = "none";
      this.style.display = "none";
      document.getElementById("menuOpen").style.display = "block";
    };

    // TODO: add on the fly correlation generation based on inputed paramaters (e.g., colour similarity, date proximity, etc.)



    // TODO: add a way to reset zoom and pan
    // TODO: add parallel and dynamic loading of images with progress bar
    // TODO: add a button to reset the random values applied to scaling
    // TODO: explore famous artists through their unique node layouts?

    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    // --- Config ---
    const IMG_SRC = id => `assets/images/portfolio/${id}.png`;
    const BASE_BOX = 220, MIN_BOX = 64, MAX_BOX = 300;
    const COLLIDE_PAD = 0;
    const DIST_MIN = 10, DIST_MAX = 1600;
    const CHARGE = -420;

    // --- Modular slider wiring ---
    const inputEls = [
      document.getElementById("charge"),
      document.getElementById("distMin"),
      document.getElementById("distMax")
    ];
    const displayEls = [
      document.getElementById("chargeDisplay"),
      document.getElementById("distMinDisplay"),
      document.getElementById("distMaxDisplay")
    ];
    const labels = ["Charge Mult", "Dist Min Mult", "Dist Max Mult"];

    const alphaDisplay = document.getElementById("alphaDisplay");

    function getScaledValue(i) {
      const raw = Number(inputEls[i].value);
      return i === 0 ? raw : raw * 0.1;
    }

    function updateDisplays() {
      for (let i = 0; i < inputEls.length; i++) {
        const v = getScaledValue(i);
        displayEls[i].innerHTML = `${labels[i]}: ${v.toFixed(2)}`;
      }
      alphaUpdate();
    }

    function simUpdate() {
      if (!sim) return;
      const chargeVal = getScaledValue(0);
      const distMinVal = getScaledValue(1);
      const distMaxVal = getScaledValue(2);

      sim.force("link").distance(l =>
        (DIST_MIN * distMinVal) + (1 - l.value) * ((DIST_MAX * distMaxVal) - (DIST_MIN * distMinVal))
      );
      sim.force("charge", d3.forceManyBody().strength(chargeVal * CHARGE));
    }

    function alphaUpdate() {
      if (sim) {
        alphaDisplay.innerHTML = sim.alpha().toFixed(3);
        alphaDisplay.style.color = (sim.alpha() < 0.01) ? "green" : "red";
      }
    }
    function toggleLinks() {
      const hide = document.getElementById("hideConnections").checked;
      for (const l of links) {
        l.value = hide ? 0 : l._baseValue;
      }
      render();
    }
    document.getElementById("hideConnections").onchange = toggleLinks;

    // Attach common handlers
    for (let i = 0; i < inputEls.length; i++) {
      const input = inputEls[i];
      input.oninput = function () {
        if (!sim) return;
        simUpdate();
        updateDisplays();
        sim.alphaTarget(0.4).restart();
      };
      input.onchange = function () {
        if (!sim) return;
        sim.alphaTarget(0);
      };
    }

    // Init
    function sliderInit() {
      updateDisplays();
      simUpdate();
    }


    // --- Canvas setup ---
    const canvas = document.getElementById("photoCanvas");
    const ctx = canvas.getContext("2d");
    let dpr = window.devicePixelRatio || 1;

    // --- State ---
    let nodes = [], links = [], sim;
    let transform = d3.zoomIdentity;
    const imgs = new Map();

    // --- Helper functions ---
    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

    function px(ev) { return d3.pointer(ev, canvas); }
    function world([x, y]) { return transform.invert([x, y]); }
    function pxToWorld(ev) { return world(px(ev)); }

    function hit(ev) {
      const [mx, my] = pxToWorld(ev);
      for (let i = nodes.length - 1; i >= 0; i--) {
        const n = nodes[i], x = n.x - n.w / 2, y = n.y - n.h / 2;
        if (mx >= x && mx <= x + n.w && my >= y && my <= y + n.h) return n;
      }
      return null;
    }

    // --- Rendering (hoisted so safe to call anytime) ---
    function setView() {
      ctx.setTransform(transform.k * dpr, 0, 0, transform.k * dpr, transform.x * dpr, transform.y * dpr);
    }

    function drawLinks() {
      for (const l of links) {
        const c = l.value;
        ctx.strokeStyle = "#000";
        ctx.globalAlpha = c;
        ctx.lineWidth = Math.max(1, (1 + 2 * c) / transform.k);
        ctx.beginPath();
        ctx.moveTo(l.source.x, l.source.y);
        ctx.lineTo(l.target.x, l.target.y);
        ctx.stroke();
      }
    }

    function drawNodes() {
      ctx.globalAlpha = 1;
      for (const n of nodes) {
        const x = n.x - n.w / 2, y = n.y - n.h / 2;
        const im = imgs.get(n.id);
        if (im) ctx.drawImage(im, x, y, n.w, n.h);
        else { ctx.fillStyle = "#2b2f3a"; ctx.fillRect(x, y, n.w, n.h); }
      }
    }


    function render() {
      if (!canvas.width) return;
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      setView();
      drawLinks();
      drawNodes();
      ctx.restore();
      alphaUpdate();
    }

    // --- Zoom / Pan ---
    const zoom = d3.zoom()
      .scaleExtent([0.25, 4])
      .filter(ev => {
        if (ev.type === "wheel") return true;
        if (ev.touches && ev.touches.length > 1) return true;
        return !hit(ev);
      })
      .on("zoom", ev => { transform = ev.transform; render(); });

    const sel = d3.select(canvas).call(zoom);
    sel.call(zoom.translateTo, 0, 0);

    // --- Resize --- 
    function resize() {
      dpr = window.devicePixelRatio || 1;
      const w = innerWidth, h = innerHeight;
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      canvas.style.width = w + "px"; canvas.style.height = h + "px";
      sel.call(zoom.translateTo, 0, 0);
      render();
    }
    addEventListener("resize", resize);

    // --- Drag ---
    const drag = d3.drag()
      .container(() => canvas)
      .subject(hit)
      .on("start", ev => {
        if (!sim) return;
        if (!ev.active) sim.alphaTarget(0.4).restart();
        const [mx, my] = pxToWorld(ev.sourceEvent);
        ev.subject._grab = { dx: ev.subject.x - mx, dy: ev.subject.y - my };
        ev.subject.fx = ev.subject.x; ev.subject.fy = ev.subject.y;
      })
      .on("drag", ev => {
        const [mx, my] = pxToWorld(ev.sourceEvent);
        const g = ev.subject._grab || { dx: 0, dy: 0 };
        ev.subject.fx = mx + g.dx; ev.subject.fy = my + g.dy;
        render();
      })
      .on("end", ev => {
        if (!ev.active) sim.alphaTarget(0);
        ev.subject.fx = null; ev.subject.fy = null;
        delete ev.subject._grab;
      });

    sel.call(drag);

    // --- Click / Cursor ---
    canvas.addEventListener("click", ev => {
      const n = hit(ev);
      if (n) window.open(n.url, "_blank");
    });

    canvas.addEventListener("mousemove", ev => {
      canvas.style.cursor = hit(ev) ? "grab" : "default";
    });

    // --- Build graph from JSON ---
    function buildGraph(arr) {
      const ns = arr.map((d, i) => {
        const id = String(d.id ?? (i + 1));
        const box = clamp(Math.round((d.scale ?? 0.5) * BASE_BOX), MIN_BOX, MAX_BOX);
        return {
          id, colour: d.colour, w: box, h: box, url: IMG_SRC(id),
          x: (Math.random() - 0.5) * 50, y: (Math.random() - 0.5) * 50
        };
      });
      const map = new Map(ns.map(n => [n.id, n]));
      const ls = [];
      for (const d of arr) {
        const a = String(d.id);
        for (const [b, v] of Object.entries(d.correlations || {})) {
          if (a === b) continue;
          const corr = clamp(Number(v) || 0, 0, 1);
          if (!corr || !map.has(a) || !map.has(b)) continue;
          if (a < b) ls.push({ source: a, target: b, value: corr });
        }
      }
      return { nodes: ns, links: ls };
    }

    // --- Image preload ---
    // --- Image preload (assign real aspect ratio to each node) ---
    async function loadAndAssignImages() {
      const MAX_SIDE = BASE_BOX; // desired longest edge size

      await Promise.all(nodes.map(async (n) => {
        const im = new Image();
        im.decoding = "async";
        im.src = n.url;

        await new Promise((resolve) => {
          im.onload = resolve;
          im.onerror = resolve;
        });

        if (im.width && im.height) {
          const aspect = im.width / im.height;
          if (aspect >= 1) {
            // wide image
            n.w = MAX_SIDE;
            n.h = MAX_SIDE / aspect;
          } else {
            // tall image
            n.h = MAX_SIDE;
            n.w = MAX_SIDE * aspect;
          }
          imgs.set(n.id, im);
        }
      }));
    }

    // --- Boot ---
    (async function init() {
      resize();
      const data = await fetch("portfolioTable.json", { cache: "no-store" }).then(r => r.json());
      ({ nodes, links } = buildGraph(data));

      // preload images and set node sizes
      await loadAndAssignImages();

      sim = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links)
          .id(d => d.id)
          .distance(l => DIST_MIN + (1 - l.value) * (DIST_MAX - DIST_MIN))
          .strength(l => 0.15 + 0.85 * l.value))
        .force("charge", d3.forceManyBody().strength(charge))
        .force("x", d3.forceX().strength(0.03))
        .force("y", d3.forceY().strength(0.09))
        .force("collide", d3.forceCollide()
          .radius(d => Math.max(d.w, d.h) / 2 + COLLIDE_PAD)
          .iterations(3))
        .on("tick", render);

      sim.alpha(1).restart();

      // update sliders

      sliderInit();
      render();
    })();
  </script>

</body>

</html>