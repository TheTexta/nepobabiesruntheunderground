<html>

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/png" href="assets/images/favicons/favicon.png" />
</head>

<body style="margin:0px">
  <main>
    <canvas id="photoCanvas" style="height:100%;width:100%; margin:0px;
  image-rendering: -webkit-optimize-contrast;image-rendering: -moz-crisp-edges;
  image-rendering: pixelated;"></canvas>
  </main>

  <script type="module">
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    // --- Config ---
    const IMG_SRC = id => `assets/images/portfolio/${id}.png`;
    const BASE_BOX = 220, MIN_BOX = 64, MAX_BOX = 300;
    const COLLIDE_PAD = 0;
    const DIST_MIN = 10, DIST_MAX = 1600;
    const CHARGE = -420;

    // --- Canvas setup ---
    const canvas = document.getElementById("photoCanvas");
    const ctx = canvas.getContext("2d");
    let dpr = window.devicePixelRatio || 1;

    // --- State ---
    let nodes = [], links = [], sim;
    let transform = d3.zoomIdentity;
    const imgs = new Map();

    // --- Helper functions ---
    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

    function px(ev) { return d3.pointer(ev, canvas); }
    function world([x, y]) { return transform.invert([x, y]); }
    function pxToWorld(ev) { return world(px(ev)); }

    function hit(ev) {
      const [mx, my] = pxToWorld(ev);
      for (let i = nodes.length - 1; i >= 0; i--) {
        const n = nodes[i], x = n.x - n.w / 2, y = n.y - n.h / 2;
        if (mx >= x && mx <= x + n.w && my >= y && my <= y + n.h) return n;
      }
      return null;
    }

    // --- Rendering (hoisted so safe to call anytime) ---
    function setView() {
      ctx.setTransform(transform.k * dpr, 0, 0, transform.k * dpr, transform.x * dpr, transform.y * dpr);
    }

    function drawLinks() {
      for (const l of links) {
        const c = l.value;
        ctx.strokeStyle = "#000";
        ctx.globalAlpha = 0.5 + 0.5 * c;
        ctx.lineWidth = Math.max(1, (1 + 2 * c) / transform.k);
        ctx.beginPath();
        ctx.moveTo(l.source.x, l.source.y);
        ctx.lineTo(l.target.x, l.target.y);
        ctx.stroke();
      }
    }

    function drawNodes() {
      ctx.globalAlpha = 1;
      for (const n of nodes) {
        const x = n.x - n.w / 2, y = n.y - n.h / 2;
        const im = imgs.get(n.id);
        if (im) ctx.drawImage(im, x, y, n.w, n.h);
        else { ctx.fillStyle = "#2b2f3a"; ctx.fillRect(x, y, n.w, n.h); }
      }
    }


    function render() {
      if (!canvas.width) return;
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      setView();
      drawLinks();
      drawNodes();
      ctx.restore();
    }

    // --- Zoom / Pan ---
    const zoom = d3.zoom()
      .scaleExtent([0.25, 4])
      .filter(ev => {
        if (ev.type === "wheel") return true;
        if (ev.touches && ev.touches.length > 1) return true;
        return !hit(ev);
      })
      .on("zoom", ev => { transform = ev.transform; render(); });

    const sel = d3.select(canvas).call(zoom);
    sel.call(zoom.translateTo, 0, 0);

    // --- Resize ---
    function resize() {
      dpr = window.devicePixelRatio || 1;
      const w = innerWidth, h = innerHeight;
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      canvas.style.width = w + "px"; canvas.style.height = h + "px";
      sel.call(zoom.translateTo, 0, 0);
      render();
    }
    addEventListener("resize", resize);

    // --- Drag ---
    const drag = d3.drag()
      .container(() => canvas)
      .subject(hit)
      .on("start", ev => {
        if (!sim) return;
        if (!ev.active) sim.alphaTarget(0.3).restart();
        const [mx, my] = pxToWorld(ev.sourceEvent);
        ev.subject._grab = { dx: ev.subject.x - mx, dy: ev.subject.y - my };
        ev.subject.fx = ev.subject.x; ev.subject.fy = ev.subject.y;
      })
      .on("drag", ev => {
        const [mx, my] = pxToWorld(ev.sourceEvent);
        const g = ev.subject._grab || { dx: 0, dy: 0 };
        ev.subject.fx = mx + g.dx; ev.subject.fy = my + g.dy;
        render();
      })
      .on("end", ev => {
        if (!ev.active) sim.alphaTarget(0);
        ev.subject.fx = null; ev.subject.fy = null;
        delete ev.subject._grab;
      });

    sel.call(drag);

    // --- Click / Cursor ---
    canvas.addEventListener("click", ev => {
      const n = hit(ev);
      if (n) window.open(n.url, "_blank");
    });

    canvas.addEventListener("mousemove", ev => {
      canvas.style.cursor = hit(ev) ? "grab" : "default";
    });

    // --- Build graph from JSON ---
    function buildGraph(arr) {
      const ns = arr.map((d, i) => {
        const id = String(d.id ?? (i + 1));
        const box = clamp(Math.round((d.scale ?? 0.5) * BASE_BOX), MIN_BOX, MAX_BOX);
        return {
          id, colour: d.colour, w: box, h: box, url: IMG_SRC(id),
          x: (Math.random() - 0.5) * 50, y: (Math.random() - 0.5) * 50
        };
      });
      const map = new Map(ns.map(n => [n.id, n]));
      const ls = [];
      for (const d of arr) {
        const a = String(d.id);
        for (const [b, v] of Object.entries(d.correlations || {})) {
          if (a === b) continue;
          const corr = clamp(Number(v) || 0, 0, 1);
          if (!corr || !map.has(a) || !map.has(b)) continue;
          if (a < b) ls.push({ source: a, target: b, value: corr });
        }
      }
      return { nodes: ns, links: ls };
    }

    // --- Image preload ---
    // --- Image preload (assign real aspect ratio to each node) ---
    async function loadAndAssignImages() {
      const MAX_SIDE = BASE_BOX; // desired longest edge size

      await Promise.all(nodes.map(async (n) => {
        const im = new Image();
        im.decoding = "async";
        im.src = n.url;

        await new Promise((resolve) => {
          im.onload = resolve;
          im.onerror = resolve;
        });

        if (im.width && im.height) {
          const aspect = im.width / im.height;
          if (aspect >= 1) {
            // wide image
            n.w = MAX_SIDE;
            n.h = MAX_SIDE / aspect;
          } else {
            // tall image
            n.h = MAX_SIDE;
            n.w = MAX_SIDE * aspect;
          }
          imgs.set(n.id, im);
        }
      }));
    }


    // --- Boot ---
    (async function init() {
      resize();
      const data = await fetch("portfolioTable.json", { cache: "no-store" }).then(r => r.json());
      ({ nodes, links } = buildGraph(data));

      // preload images and set node sizes
      await loadAndAssignImages();

      sim = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links)
          .id(d => d.id)
          .distance(l => DIST_MIN + (1 - l.value) * (DIST_MAX - DIST_MIN))
          .strength(l => 0.15 + 0.85 * l.value))
        .force("charge", d3.forceManyBody().strength(CHARGE))
        .force("x", d3.forceX().strength(0.15))
        .force("y", d3.forceY().strength(0.15))
        .force("collide", d3.forceCollide()
          .radius(d => Math.max(d.w, d.h) / 2 + COLLIDE_PAD)
          .iterations(3))
        .on("tick", render);

      sim.alpha(1).restart();
      render();
    })();
  </script>

</body>

</html>